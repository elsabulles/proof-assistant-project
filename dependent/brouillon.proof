
Brouillon
define scom = fun (k : Nat) -> (fun (n : Nat) -> ( fun (e : (add k n) = (add n k) ) -> (J (fun (x1 : Nat) -> (fun (x2 : Nat) -> (fun (eq : x1=y2) -> ( (add (S k) n) = (S x1)) ))) (psuccomm k n) (add k n) (add n k) e )))
define addcomm = (fun (l : Nat) -> (fun (n : Nat) -> ( Ind (pcomm (zadd l) (scom l) n))))

cat appid.proof | dune exec ./prover.exe
cat petitsessais.proof | dune exec ./prover.exe

define scom = fun (k : Nat) -> fun (n : Nat) -> fun (e : (add k n) = (add n k) ) -> J (fun (x1 : Nat) -> fun (x2 : Nat) -> fun (eq : x1 = x2) -> (add (S k) n) = (S x1)) (psuccomm k n) (add k n) (add n k) e 
define addcomm = fun (l : Nat) -> fun (n : Nat) -> Ind pcomm (zadd l) (scom l) n
eval cong Nat Nat Z Z (fun (x : Nat) -> S x) Refl(Z)

s = (fun (k : Nat) -> (e : (add k n) = (add n k)) -> trans Nat (add (S k) n) (S (add k n)) (S (add n k)) (succomm k n) (congsuc (add k n) (add n k) e))

define succaddcomm = fun (n : Nat) -> fun (k : Nat) -> (e : (add k n) = (add n k)) -> trans Nat (add (S k) n) (S (add k n)) (S (add n k)) (succomm k n) (congsuc (add k n) (add n k) e)
check succaddcomm = Pi (n : Nat) -> Pi (k : Nat) -> Pi (e : (add k n) = (add n k)) -> add (S k) n = S (add n k)

define addcomm = fun (n : Nat) -> fun (k : Nat) -> Ind (pcomm n) (zadd n) (succaddcomm n) k

define succaddcomm = fun (n : Nat) -> fun (k : Nat) -> (e : (add k n) = (add n k)) -> (trans Nat (add (S k) n) (S (add k n)) (S (add n k)) (succomm k n) (congsuc (add k n) (add n k) e))

define trans = fun (A : Type) -> fun (x : A) -> fun (y : A) -> fun (z : A) -> fun (xey : x=y) -> J (ptrans A z) (fun (x : A) -> fun (xez : x=z) -> xez) x y xey
check trans = Pi (A : Type) -> Pi (x : A) -> Pi (y : A) -> Pi (z : A) -> Pi (xey : x=y) -> Pi (yez : y=z) -> x=z

assume n  : Nat 
assume k : Nat
assume l : Nat
assume e1 : n=k
assume e2 : k=l
type (trans Nat n k l e1 e2)

Typing error :J ((fun : x6774 : Nat -> (fun : x6782 : Nat -> (fun : x6786 : ( x6774 = x6782 ) -> (Π x6788 : ( x6782 = l ) -> ( x6774 = l ))))), (fun : x6771 : Nat -> (fun : x6773 : ( x6771 = l ) -> x6773)), n, k, e1) is not a function type when inferring the type.

Pourtant, d'après les règles de réduction, le type est : (Π x6788 : ( x6782 = l ) -> ( x6774 = l )) avec x6782 = k et x6774=n 
donc de type (Π x6788 : ( k = l ) -> ( n = l )) qui est bien un "function type ?"


assume n  : Nat 
assume k : Nat
assume l : Nat
assume e : (add k n) = (add n k)
check (succomm k n) = (add (S k) n) = (S (add k n))
check congsuc (add k n) (add n k) e = (S (add k n) = S (add n k))
assume e1 : n=k
assume e2 : k=l
eval ptrans Nat l n k e1
type (trans Nat n k l e1 e2)

PAST MISTAKE :
define scom = fun (k : Nat) -> fun (n : Nat) -> fun (e : (add k n) = (add n k) ) -> J (fun (x1 : Nat) -> fun (x2 : Nat) -> fun (eq : x1 = x2) -> (add (S k) n) = (S x1)) (psuccomm k n) (add k n) (add n k) e 


eval (trans Nat (add (S k) n) (S (add k n)) (S (add n k)) (succomm k n) (congsuc (add k n) (add n k) e))???


define addcomm = fun (n : Nat) -> fun (k : Nat) -> Ind (pcomm n) (zadd n) (succaddcomm n) k


assume n : Nat
assume k : Nat
define addcommnk = Ind (pcomm n) (zadd n) (succaddcomm n) k

define s1mult = fun (n : Nat) -> fun (hr : mult one n = n) -> trans Nat (mult one (S k)) (S (mult one k))
define 1mult = fun (n : Nat) -> Ind p1mult Refl(Z) () n